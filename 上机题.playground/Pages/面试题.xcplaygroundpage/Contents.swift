//开头
/*:
 ## 语法
 1. 多线程
 2. 优化
 3. 运行时
 4.      
 1. 简述一下KVC和KVO使用场景，使用过程中需要注意些什么？
 2. 使用cocoapods引入第三方库时，sdk之间的出现冲突如何解决？
 3. 在项目中关于TCP或者UDP编程的使用过程
 4. nil/Nil/NULL/NSNull区别？
 nil：指向引用类型对象的空指针，对nil的方法调用不会崩溃。
 用途：把一个对象置空，完全从内存中释放。
 Nil：和nil含义作用相同，只是在编程习惯上存在区别：把一个类置空使用Nil
 NULL：指向值类型的的空指针
 
 NSNull：是OC类继承自NSObject，值为空的对象，拥有一个有效的内存地址。引用不会崩溃，调用就会崩溃。
 4. 请描述下ARC原理
 ARC的规则就是只要对象没有强指针引用，就会被释放掉，换而言之 只要还有一个强引用指针变量指向对象，那么这个对象就会存在内存中。弱指针指向的对象，会被自动变成空指针（nil指针），从而不会引发野指针错误。
 原理是:在编译代码的时候为你自动在合适的位置插入release 和 autorelease, (运行时处理垃圾回收就如何MRC一样).
 5. MRC和ARC是如何破循环引用的
 6. 使用索引的缺点用哪些？
 7. 使用过HTTP请求的那些方法，什么时候使用get，post，put？
 8. 描述一下TCP建立连接的过程，断开连接的过程，为什么是三次握手？
 9. 发布后的版本，怎么搜集crash日志？不实用bugly等第三方平台或者这些第三方平台是怎么搜集crash 日志的？
 10. 说一下runtime，为什么OC里面是发消息，而C/C++是函数调用？
 11. 说下OC发消息的过程
 因为OC是基于运行时编程语言，在编译中并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。
 OC函数调用属于消息发送机制的动态调用的过程，当oc对象调用起方法时，实际是通过运行时的发送消息的函数来实现方法调用的。在运行时对象和类都是结构体形式存在的，
 发送消息：先获取一个存放方法名的方法选择器，来查找对应方法的函数指针，然后调用函数。
 SEL查找过程：先从对象的isa指针找到关联的class，然后sel在cache/方法列表中查找方法明对应函数method，然后存储到cache中方便下次调用时查找，并通过函数指针跳转到函数实现中运行代码。如果没有找到，会通过class中的isa关联指针，顺延至superclass的结构体中查找。
 12. 什么是OC对象，union是OC对象吗，block 是OC对象吗
 13. id是什么类型
 是指向对象实例的变量的指针
 ```oc
 typedef struct objc_object{
 Class isa;
 } *id;
 ```
 14. 解决过的最精彩的crash问题？
 15. 子线程中调用connection方法，为什么不回调？
 16. autorelease变量什么时候释放发？
 autorelease对象内存的管理放到autoreleasepool中, 当pool drain时,回收内存. (这是基于 objective-c的运行时特性和垃圾回收机制)
 17. GCD和NSOperation的区别？
 
 18. weak和assign的区别
 weak 不会产生野指针问题。因为weak修饰的对象释放后（引用计数器值为0），指针会自动被置nil，之后再向该对象发消息也不会崩溃。 weak是安全的。
 assign 如果修饰对象，会产生野指针问题；如果修饰基本数据类型则是安全的。修饰的对象释放后，指针不会自动被置空，此时向对象发消息会崩溃。
 assign 适用于基本数据类型如int,float,struct等值类型，不适用于引用类型。因为值类型会被放入**栈**中，遵循先进后出原则，由系统负责管理栈内存。而引用类型会被放入**堆**中，需要我们自己手动管理内存或通过ARC管理。
 weak 适用于delegate和block等引用类型，不会导致野指针问题，也不会循环引用，非常安全。
 19. 堆和栈的区别
 栈：遵循先进后出原则，
 栈有两种分配方式：静态分配和动态分配
 * 静态分配是系统编译器完成的，比如局部变量的分配
 * 动态分配是有alloc函数进行分配的，但是栈的动态分配和堆是不同的，它的动态分配也由系统编译器进行释放，不需要程序员手动管理
 堆：遵循先进先出原则，堆是动态分配和回收内存的，没有静态分配的堆
 ## 算法
 ## 第三方库
 ## 项目经验
 */






